## 注解

> 当实体类和表名不一致时，可以使用注解@TableName

设置实体类所对应的表名。

```java
@Data
@TableName("t_user")
public class User {
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

如果所有的表名都像这样的配置，其实也是挺麻烦的。因此mybatis-plus也有解决方法：**在全局配置文件中进行配置**

```yml
mybatis-plus:
  configuration:
  	# 设置打印sql语句
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
   # 设置mapper的位置
#  mapper-locations:
  global-config:
    db-config:
      # 设置实体类所对应的表名的统一前缀
      table-prefix: t_
      # 设置统一的主键生成策略
      id-type: auto
```

> mybatis-plus只能将id作为主键，这是默认的；如果表中的主键名不是id，可以通过注解@TableId将当前的字段作为主键，所以id就不再是主键。

假设当前数据库的id变成了uid

```java
@Data
@TableName("t_user")
public class User {
    @TableId
    private Long uid;
    private String name;
    private Integer age;
    private String email;
}
```

或者

```java
@Data
@TableName("t_user")
public class User {
    // @TableId注解的value属性用于指定主键的字段
    @TableId(value = "uid")
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

下来添加设置自增：

```java
@Data
//@NoArgsConstructor
//@AllArgsConstructor
//@EqualsAndHashCode
//@Getter
//@Setter
public class User {
    # @TableId注解的type属性设置主键生成策略
    @TableId(value = "uid", type = IdType.AUTO)
    private Long id;
    private String name;
    private Integer age;
    private String email;
}
```

下面是IdType的实现类：

```java
/**
 * 生成ID类型枚举类
 *
 * @author hubin
 * @since 2015-11-10
 */
@Getter
public enum IdType {
    /**
     * 数据库ID自增
     * <p>该类型请确保数据库设置了 ID自增 否则无效</p>
     */
    AUTO(0),
    /**
     * 该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)
     */
    NONE(1),
    /**
     * 用户输入ID
     * <p>该类型可以通过自己注册自动填充插件进行填充</p>
     */
    INPUT(2),

    /* 以下2种类型、只有当插入对象ID 为空，才自动填充。 */
    /**
     * 分配ID (主键类型为number或string）,
     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(雪花算法)
     *
     * @since 3.3.0
     */
    ASSIGN_ID(3),
    /**
     * 分配UUID (主键类型为 string)
     * 默认实现类 {@link com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(UUID.replace("-",""))
     */
    ASSIGN_UUID(4);

    private final int key;

    IdType(int key) {
        this.key = key;
    }
}
```

> @TableId的type属性定义主键策略

**常用的主键策略：**

| 值                       | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| IdType.ASSIGN_ID（默认） | 基于雪花算法的策略生成数据id，与数据库的id是否设置自增无关   |
| IdType.AUTO              | 使用数据库的自增策略，注意，该类型请确保数据库设置了id自增，否则无效 |

**注意：**当我们在新增数据时，主动设置了id值，那么就不会使用雪花算法或者自增生成id，前提是id不能存在重复。

```java
@Test
public void testInsert() {
    User user = new User();
    user.setName("ybc");
    user.setAge(20);
    user.setId(200l);
    boolean b = userService.save(user);
    System.out.println(b);
}
```

![image-20240830114346127](https://cdn.jsdelivr.net/gh/lqyspace/AI-master-img@master/img/202408301143165.png)

当然我们在设置全局配置文件中也可手动设置统一的主键生成策略：

```yml
mybatis-plus:
  configuration:
  	# 设置打印sql语句
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
   # 设置mapper的位置
#  mapper-locations:
  global-config:
    db-config:
      # 设置实体类所对应的表名的统一前缀
      table-prefix: t_
      # 设置统一的主键生成策略
      id-type: auto
```

> **@TableField**：指定属性所对应的字段名

```java
@Data
//@NoArgsConstructor
//@AllArgsConstructor
//@EqualsAndHashCode
//@Getter
//@Setter
public class User {
    # @TableId注解的type属性设置主键生成策略
    @TableId(value = "uid", type = IdType.AUTO)
    private Long id;
    @TableField("user_name")
    private String name;
    private Integer age;
    private String email;
}
```

**注意：在mybatis中，默认会使用小驼峰命名法与数据库中的字段名进行联系：比如java实体类的属性名是`userName`，那么在数据库中的字段就应该是`user_name`。除非，可以使用上面的@TableField。**



