[toc]

# 逻辑删除与真实删除

## 逻辑删除

- 物理删除：真实删除，将对应数据中数据库中删除，之后查询不到此条被删除的数据
- 逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧可以看到该条数据记录
- 使用场景：可以进行数据恢复

## 实现逻辑删除

> 第一步，数据库中创建逻辑删除状态列，设置默认值为0

![image-20240830144002300](https://cdn.jsdelivr.net/gh/lqyspace/AI-master-img@master/img/202408301440343.png)

> 第二步，在实体类中添加相应的字段，并将该字段标记为@TableLogic

```java
@Data
//@NoArgsConstructor
//@AllArgsConstructor
//@EqualsAndHashCode
//@Getter
//@Setter
public class User {
    @TableId(value = "uid", type = IdType.AUTO)
    private Long id;
    private String name;
    private Integer age;
    private String email;
    @TableLogic
    private Integer isDeleted;
}
```

> 执行删除操作，就会把删除功能变为修改功能

```java
@Test
public void testDelete(){
//        int result = userMapper.deleteById(1);
//        System.out.println("result:" + result);
//        Map<String, Object> map = new HashMap<>();
//        map.put("name", "zhangsan");
//        map.put("age", 20);
//        int result = userMapper.deleteByMap(map);
//        System.out.println("result:" + result);
    List<Long> ids = Arrays.asList(4l, 5l, 6l);
    int result = userMapper.deleteBatchIds(ids);
    System.out.println("result:" + result);
}
```

![image-20240830144253812](https://cdn.jsdelivr.net/gh/lqyspace/AI-master-img@master/img/202408301442858.png)

然后执行查询操作，就会发现被软删除的记录不会显示：

```java
@Test
public void testSelectList(){
    List<User> list = userMapper.selectList(null);
    list.forEach(System.out::println);
}
```

![image-20240830144427595](https://cdn.jsdelivr.net/gh/lqyspace/AI-master-img@master/img/202408301444638.png)