[toc]

# 快速开发

```java
获取当前月份    LocalDateTime.now()    LocalDate.now()
更新表达式       LambdaUpdateWrapper<CardMonthUsed> cardMonthUsedLambdaQueryWrapper = new LambdaUpdateWrapper<>();
查询表达式       LambdaQueryWrapper<CardPoolInfo> lambdaQueryWrapper = new LambdaQueryWrapper<>();
获取月份          Long monthLong = com.bw.iot.im.commons.utils.BwDateUtil.getMonthLong(); 
判空                cn.hutool.core.util.ObjectUtil.isNotEmpty()；
判空                com.bw.iot.im.commons.utils.CheckUtils.isNotEmpty()
属性复制          org.springframework.beans.BeanUtils.copyProperties(old, new)
```



# nacos

```yml
1、http://mse-dab04190-p.nacos-ans.mse.aliyuncs.com:8848/nacos/#/configurationManagement?dataId=&group=&appName=&namespace=iot-im-config&pageSize=&pageNo=&namespaceShowName=iot-im-config
2、http://mse-dab04190-p.nacos-ans.mse.aliyuncs.com:8848/nacos/#/configurationManagement?dataId=&group=&appName=&namespace=iot-im-rpc&pageSize=&pageNo=&namespaceShowName=iot-im-rpc
3、http://mse-dab04190-p.nacos-ans.mse.aliyuncs.com:8848/nacos/#/configurationManagement?dataId=&group=&appName=&namespace=iot-oc-config&pageSize=&pageNo=&namespaceShowName=iot-oc-config
```



> [!tip]
>
> 编辑模块时，先编辑model，再编辑interface，最后编辑provider。
> 如果涉及到portal的模块，在model编辑后，portal模块还需要重新编辑。



# ES

```yml
link_point__card_basic

iot_im__card_info

- iccid

- multi_net_id

flow__card_month_flow_now

link_point__card_reseller_relation

GET agg6__card_basic__card_info__0/_search
{
  "query": {
     "bool": {
       "filter": [
         {"exists": {
           "field": "link_point__card_basic"
         }}
       ]
     }
  }
  ,"_source": [
    "iot_im__card_info",
    "iccid",
    "multi_net_id"
    ]
}
```



## QueryBuilders.termQuery 和 QueryBuilders.termsQuery的区别

> [!tip]
>
> - `QueryBuilders.termQuery`
>
>   - `termQuery` 用于对某个字段进行**精确的值匹配**
>
>   - 当你想查询某个字段的值等于某个指定值时
>
>   - 传入的参数是一个单一值
>
>     ```java
>     QueryBuilders.termQuery("field_name", "value");
>     ```
>
> - `QueryBuilders.termsQuery`
>
>   - `termsQuery` 用于对某个字段**进行多个值的精确匹配**
>
>   - 当你想查询某个字段的值是否等于多个值中的任何一个时
>
>   - 传入的参数是一个集合或数组
>
>     ```java
>     QueryBuilders.termsQuery("field_name", "value1", "value2", "value3");
>     ```
>
>     ```java
>     QueryBuilders.termsQuery("status", "active", "pending");
>     
>     
>     List<String> statuses = Arrays.asList("active", "pending", "completed");
>     QueryBuilders.termsQuery("status", statuses);
>     ```



## QueryBuilders.rangeQuery的用法

> 作用：在Elasticsearch中用于范围查询，适用于查询字段值在特定范围内的文档。常用于数值，日期，或者其他可以排序的字段类型。
>
> **基本用法：**可以设置范围的上下界，比如大于，等于，小于等于某个值。
>
> **语法：**
>
> ```java
> QueryBuilders.rangeQuery("field_name")
>     .from(startValue)   // 设置范围的起点
>     .to(endValue)       // 设置范围的终点
>     .includeLower(true) // 是否包含下限
>     .includeUpper(false); // 是否包含上限
> 
> ```
>
> 主要方法：
>
> - `from(Object value)`：设置查询范围的起始值
> - `to(Object value)`：设置查询范围的结束值
> - `gt(Object value)`：查询字段值大于指定值
> - `gte(Object value)`：查询字段值大于等于指定值
> - `lt(Object value)`：查询字段值小于指定值
> - `lte(Object value)`：查询字段值小于等于指定值
> - `includeLower(boolean)`：是否包含起始值，默认为`true`
> - `includeUpper(boolean)`：是否包含结束值，默认为`true`
>
> **示例：**
>
> **1.查询数值范围**
>
> 查询age字段值在20到30之间（包含20，不包含30）的文档：
>
> ```java
> QueryBuilders.rangeQuery("age")
>     .from(20)
>     .to(30)
>     .includeLower(true)   // 包含 20
>     .includeUpper(false); // 不包含 30
> ```
>
> **2.查询日期范围**
>
> 查询`created_at`字段在2022-01-01到2022-12-31之间的文档：
>
> ```java
> QueryBuilders.rangeQuery("created_at")
>     .gte("2022-01-01")
>     .lte("2022-12-31");
> ```
>
> **3.使用gt和lt**
>
> 查询`price`字段大于100并小于500的文档：
>
> ```java
> QueryBuilders.rangeQuery("price")
>     .gt(100)
>     .lt(500);
> ```
>
> **4.使用gte和lte**
>
> 查询`height`字段大于等于150并小于等于180的文档：
>
> ```java
> QueryBuilders.rangeQuery("height")
>     .gte(150)  // 大于等于 150
>     .lte(180); // 小于等于 180
> ```
>
> #### 总结
>
> - `rangeQuery` 主要用于范围查询。
> - 支持 `from` 和 `to` 的传统区间设置，也支持 `gt`（大于）、`lt`（小于）等精确控制范围的操作。
> - 对于日期和数值查询非常常用，可以根据业务需求灵活调整。



## QueryBuilders.existsQuery的用法

`QueryBuilders.existsQuery`在Elastcisearch中用于查询指定字段是否存在的文档。也就是说，它可以用来查找那些包含特定字段的文档，而不关心字段的值。

**基本用法：**

```java
QueryBuilders.existsQuery("field_name");
```

其中，`filed_name`是你想检查是否存在的字段名。

**示例：**

**1.查询某字段是否存在**

假设我们想查询`age`字段存在的文档：

```java
QueryBuilders.existsQuery("age")
```

**2.用于组合查询**

`exitsQuery`通常和其他的查询条件一起使用，尤其是通过`boolQuery`进行组合查询。

```java
QueryBuilders.boolQuery()
    .must(QueryBuilders.existsQuery("age")) # age字段必须存在
    .must(QueryBuilders.termQuery("status", "active")); # 并且 status 字段必须为 "active"
```

这个是用于查询会返回那些`age`字段存在并且`status`字段为`active`的文档。

**3.小结**

- `existsQuery`是一个简单的存在性查询，用于查找某含某个字段的文档。
- 它可以与其他查询条件（如`termQuery`、`rangeQuery`等）一起使用，以便实现更复杂的查询逻辑。



## QueryBuilders.wildcardQuery的用法

`QueryBuilders.wildcardQuery`用于在Elasticsearch中执行通配符查询。它允许通过使用通配符（`*`和`?`）来匹配字段值。具体而言：

- `*`表示匹配任意长度的字符（包括空字符）
- `?`表示匹配单个字符

**基本用法**

```java
QueryBuilders.wildcardQuery("field_name", "wildcard_pattern");
```

- `field_name`：要进行通配符查询的字段名
- `wildcard_pattern`：通配符匹配的模式字符串

**示例**

**1.简单的通配符匹配**

假设我们想查询名字以`Joh`开头的文档，可以这样写：

```java
QueryBuilders.wildcardQuery("name", "Joh*");
```

这个查询会返回所有`name`字段的值以`Joh`开头的文档，比如`John`、`Johanna`等。

**2.匹配单个字符**

如果我们想查询所有名字长度为4个字符，并且第一个字母为`J`的名字：

```java
QueryBuilders.wildcardQuery("name", "J???");
```

这个查询会返回类似`Jack`、`John`等名字的文档，因为`J???`代表`J`后面有三个字符。

**3.用通配符匹配某个子字符串**

如果你想查找字段值中包含`test`的文档，可以这样写：

```java
QueryBuilders.wildcardQuery("description", "*test*");
```

这个查询会匹配任何`description`字段值中`test`的文档，比如`This is a test`、`testing123`等。

**4.与`QueryBuilders.prefixQuery`区别**

`wildcardQuery` 和 `prefixQuery` 类似，但 `wildcardQuery` 更灵活。`prefixQuery` 只允许前缀匹配，而 `wildcardQuery` 可以在任意位置使用 `*` 和 `?`。

**5.性能考虑**

通配符查询的性能相对较低，特别是在使用前置的 `*` 时，因为它需要扫描大量的文档。所以，尽量在明确需要时使用，并在索引时优化字段（例如，使用正则表达式或设置 n-gram 来处理复杂的字符串查询）。

**6.小结**

- `wildcardQuery` 是 Elasticsearch 中用于模糊匹配的查询，允许使用 `*` 和 `?`。
- 适用于需要匹配部分字段值或不确定字段完整值的场景。
- 需要注意性能问题，尤其是在使用前缀通配符（如 `"*abc"`）时。



## queryBuilders中的msut、should、mustNot、filter的用法

在Elasticsearch中，QueryBuilders的must、should、mustNot和filter是布尔查询(boolQuery)的一部分，用于查询多个条件，并且每个条件的含义都不同。通过这些查询组合，可以构建出复杂的查询逻辑。

**1.`must`：必须满足的条件**

- 类似于SQL中的`AND`，表示查询的文档必须满足该条件。
- 如果查询中的所有must条件都不满足，文档将不会被返回。

```java
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
    .must(QueryBuilders.termQuery("status", "active"))   // 必须是 active 状态
    .must(QueryBuilders.rangeQuery("age").gte(18));      // 必须年龄大于等于 18
```

这个查询返回所有 `status` 为 `"active"` 且 `age` 大于等于 18 的文档。

**2.`should`：可选的条件**

- 类似于SQL中的`OR`，表示文档可以满足该条件，但不强制。
- 如果没有`must`条件时，至少满足一个`should`条件的文档会被返回。
- 如果有`must`条件时，满足`should`条件的文档得分会更高（被认为更相关）。

```java
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
    .must(QueryBuilders.termQuery("status", "active"))   // 必须是 active 状态
    .should(QueryBuilders.termQuery("city", "New York")) // 在 New York 城市的得分会更高
    .should(QueryBuilders.termQuery("city", "San Francisco")); // 在 San Francisco 城市的得分也会更高
```

这个查询返回所有 `status` 为 `"active"` 的文档，其中如果 `city` 是 `"New York"` 或 `"San Francisco"`，则得分会更高。

**3.`mustNot`：必须不满足的条件**

- 类似于 SQL 中的 `NOT`，表示查询的文档**不能**满足该条件。
- 如果文档满足了 `mustNot` 条件，该文档将不会被返回。

```java
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
    .must(QueryBuilders.termQuery("status", "active"))   // 必须是 active 状态
    .mustNot(QueryBuilders.termQuery("city", "New York")); // 不能在 New York 城市
```

这个查询返回所有 `status` 为 `"active"` 且 `city` 不为 `"New York"` 的文档。

**4.`filter`：过滤条件（不影响得分）**

- 过滤条件，而不影响查询的相关性评分。`filter`条件是不可评分的，表示Elasticsearch只关心是否满足该条件。
- 适用于无关排序的条件，如范围查询、固定条件等，`filter`通常比`must`更快。

```java
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()
    .must(QueryBuilders.termQuery("status", "active"))   // 必须是 active 状态
    .filter(QueryBuilders.rangeQuery("age").gte(18));    // 过滤出年龄大于等于 18 的文档
```

这个查询返回所有 `status` 为 `"active"` 且 `age` 大于等于 18 的文档。`filter` 只是筛选文档，不会影响相关性得分。

**总结**

- **`must`**：文档必须满足的条件（类似 SQL 中的 `AND`）。
- **`should`**：文档可以满足的条件，如果满足多个则文档得分更高（类似 SQL 中的 `OR`）。
- **`mustNot`**：文档必须不满足的条件（类似 SQL 中的 `NOT`）。
- **`filter`**：过滤文档，不计算得分（更高效，适合固定条件）。



# 可变参数

> [!tip]
>
> 在java中，函数中的可变参数的表现形式是：`Object... values`，可变参数允许我们向函数传递多个参数，而不需要提前确定参数的数量。
>
> **详细解释：**
>
> - **`Object...`**: 这里 `Object` 是参数的类型，`...` 表示可变参数。
> - **`values`**: 这是参数的名称，它接收多个 `Object` 类型的参数。

**示例代码：**

```java
public void printValues(Object... values) {
    for (Object value : values) {
        System.out.println(value);
    }
}
```

在上面的代码中，`printValues` 函数可以接受任意数量的参数，包括零个参数。

**使用示例：**

```java
printValues();                           // 不传递参数
printValues("Apple");                    // 传递一个参数
printValues("Apple", "Banana", 42);      // 传递多个参数
```

> [!note]
>
> **注意事项：**
>
> - **可变参数是参数列表的最后一个参数，最后一个位置。**
> - 如果传递的就是一个数组，它本身会被直接作为可变参数处理，而不是将数组中的每一个元素当作单独的参数进行处理。

